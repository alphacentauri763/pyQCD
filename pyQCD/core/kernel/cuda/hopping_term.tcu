
CudaHoppingTerm::CudaHoppingTerm(const int numHops, const int L, const int T,
				 const bool precondition, const bool hermitian,
				 const Complex* boundaryConditions,
				 Complex* links, const bool copyLinks)
  : CudaLinearOperator(L, T, precondition, hermitian, links, copyLinks)
{
  // Constructor - creates Wilson spin structures.

  Complex hostGammas[64];
  createGammas(hostGammas);
  Complex hostSpinStructures[128];
  diagonalSpinMatrices(hostSpinStructures, 1.0);
  diagonalSpinMatrices(hostSpinStructures + 64, 1.0);
  subtractArray(hostSpinStructures, hostGammas, 64);
  addArray(hostSpinStructures + 64, hostGammas, 64);

  this->init(numHops, L, T, precondition, hermitian, boundaryConditions,
	     hostSpinStructures, links, copyLinks);
}



CudaHoppingTerm::CudaHoppingTerm(const int numHops, const int L, const int T,
				 const bool precondition, const bool hermitian,
				 const Complex* boundaryConditions,
				 const Complex* spinStructures,
				 const int spinLength, Complex* links,
				 const bool copyLinks)
  : CudaLinearOperator(L, T, precondition, hermitian, links, copyLinks)
{
  // Constructor - user-specified spin structures

  if (spinLength == 128)
    this->init(numHops, L, T, precondition, hermitian, boundaryConditions,
	       spinStructures, links, copyLinks);
  else {
    Complex hostSpinStructures[128];
    diagonalSpinMatrices(hostSpinStructures, 0.0);
    for (int i = 0; i < 8; ++i) {
      addArray(hostSpinStructures + 16 * i, spinStructures);
    }
    this->init(numHops, L, T, precondition, hermitian, boundaryConditions,
	       hostSpinStructures, links, copyLinks);
  }
}



CudaHoppingTerm::~CudaHoppingTerm()
{
  cudaFree(this->spinStructures_);
  cudaFree(this->neighbours_);
  cudaFree(this->evenIndices_);
  cudaFree(this->oddIndices_);
  cudaFree(this->evenNeighbours_);
  cudaFree(this->oddNeighbours_);
  cudaFree(this->boundaryConditions_);
}



void CudaHoppingTerm::init(const int numHops, const int L, const int T,
			   const bool precondition, const bool hermitian,
			   const Complex* boundaryConditions, 
			   const Complex* spinStructures, Complex* links,
			   const bool copyLinks)
{
  // Shared constructor code
  
  int numSites = L * L * L * T;
  
  // First copy over the spin structures
  cudaMalloc((void**) &this->spinStructures_, 128 * sizeof(Complex));
  cudaMemcpy(this->spinStructures_, hostSpinStructures, 128 * sizeof(Complex),
	     cudaMemcpyHostToDevice);

  // Generate boundary conditions then copy them over
  int size = 8 * numSites * sizeof(Complex);
  Complex* hostBoundaryConditions = (Complex*) malloc(size);
  generateBoundaryConditions(hostBoundaryConditions, numHops,
			     boundaryConditions, L, T);
  // Do the copy
  cudaMalloc((void**) &this->boundaryConditions_, size);
  cudaMemcpy(this->boundaryConditions_, hostBoundaryConditions, size,
	     cudaMemcpyHostToDevice);
  free(hostBoundaryConditions);

  // Now for the neighbour indices
  size = 8 * numSites * sizeof(int);
  int* hostNeighbours = (int*) malloc(size);
  generateNeighbours(hostNeighbours, numHops, L, T);

  cudaMalloc((void**) &this->neighbourIndices_, size);
  cudaMemcpy(this->neighbours_, hostIndices, size,
	     cudaMemcpyHostToDevice);

  int* hostEvenIndices = (int*) malloc(size / 16);
  int* hostOddIndices = (int*) malloc(size / 16);

  int* hostEvenNeighbours = (int*) malloc(size / 2);
  int* hostOddNeighbours = (int*) malloc(size / 2);
  
  int evenIndex = 0;
  int oddIndex = 0;
  
  for (int i = 0; i < T, ++i) {
    for (int j = 0; j < L; ++j) {
      for (int k = 0; k < L; ++k) {
	for (int l = 0; l < L; ++l) {
	  int siteIndex = l + L * (k + L * (j + L * i));
	  
	  if ((i + j + k + l) % 2 == 0) {
	    hostEvenIndices[evenIndex] = siteIndex;
	    for (int m = 0; m < 8; ++m)
	      hostEvenNeighbours[8 * evenIndex + m]
		= hostNeighbours[8 * siteIndex + m];
	    evenIndex++;
	  }
	  else {
	    hostOddIndices[oddIndex] = siteIndex;
	    for (int m = 0; m < 8; ++m)
	      hostOddNeighbours[8 * oddIndex + m]
		= hostNeighbours[8 * siteIndex + m];
	    oddIndex++;
	  }
	}
      }
    }
  }

  // Now copy all the even and odd indices over
  cudaMalloc((void**) &this->evenIndices_, size / 16);
  cudaMemcpy(this->evenIndices_, hostEvenIndices, size, cudaMemcpyHostToDevice);
  cudaMalloc((void**) &this->oddIndices_, size / 16);
  cudaMemcpy(this->oddIndices_, hostOddIndices, size, cudaMemcpyHostToDevice);
  cudaMalloc((void**) &this->evenNeighbours_, size / 16);
  cudaMemcpy(this->evenNeighbours_, hostEvenNeighbours, size,
	     cudaMemcpyHostToDevice);
  cudaMalloc((void**) &this->oddNeighbours_, size / 16);
  cudaMemcpy(this->oddNeighbours_, hostOddNeighbours, size,
	     cudaMemcpyHostToDevice);

  free(hostNeighbours);
  free(hostEvenIndices);
  free(hostEvenNeighbours);
  free(hostOddIndices);
  free(hostOddNeighbours);
}
