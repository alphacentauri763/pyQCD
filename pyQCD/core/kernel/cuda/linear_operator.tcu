
CudaLinearOperator::CudaLinearOperator(const int L, const int T,
				       const int precondition,
				       const int hermitian, Complex* links,
				       const bool copyLinks)
  : super(precondition > 0 ? 6 * L * L * L * T : 12 * L * L * L * T,
	  precondition > 0 ? 6 * L * L * L * T : 12 * L * L * L * T)
{
  this->N = 12 * L * L * L * T;
  this->L_ = L;
  this->T_ = T;

  this->precondition_ = precondition;
  this->hermitian_ = hermitian;

  // Number of complex numbers in the array of links
  if (copyLinks) {
    int size = 3 * this->N * sizeof(Complex);
    cudaMalloc((void**) &this->links_, size);
    cudaMemcpy(this->links_, links, size, cudaMemcpyHostToDevice);
  }
  else
    this->links_ = links;
}



CudaLinearOperator::~CudaLinearOperator()
{
  cudaFree(this->links_);
}



void CudaLinearOperator::operator()(const VectorTypeDev& x,
				    VectorTypeDev& y) const
{
  const Complex* x_ptr = thrust::raw_pointer_cast(&x[0]);
  Complex* y_ptr = thrust::raw_pointer_cast(&y[0]);

  if (this->precondition_) {
    if (this->hermitian_)
      this->applyPreconditionedHermitian(y_ptr, x_ptr);
    else
      this->applyPreconditioned(y_ptr, x_ptr);    
  }
  else {
    if (this->hermitian_)
      this->applyHermitian(y_ptr, x_ptr);
    else
      this->apply(y_ptr, x_ptr);
  }
}



void CudaLinearOperator::makeEvenOdd(Complex* y, const Complex* x) const
{
  // Permutes the supplied spinor, shuffling it so the upper half contains
  // the even sites and the lower half contains the odd sites

  int nSites = this->N / 12;

  for (int i = 0; i < nSites / 2; ++i) {
    for (int j = 0; j < 12; ++j)
      y[12 * i + j] = x[12 * this->evenIndices_[i] + j];
  }

  for (int i = nSites / 2; i < nSites; ++i) {
    for (int j = 0; j < 12; ++j)
      y[12 * i + j] = x[12 * this->oddIndices_[i - nSites / 2] + j];
  }
}



void CudaLinearOperator::removeEvenOdd(Complex* y, const Complex* x) const
{
  // Permutes the supplied spinor, shuffling it so it's back in lexicographic
  // order

  int nSites = this->N / 12;

  for (int i = 0; i < nSites / 2; ++i) {
    for (int j = 0; j < 12; ++j)
      y[12 * this->evenIndices_[i] + j] = x[12 * i + j];
  }

  for (int i = nSites / 2; i < nSites; ++i) {
    for (int j = 0; j < 12; ++j)
      y[12 * this->oddIndices_[i] + j] = x[12 * i + j];
  }
}



void CudaLinearOperator::makeEvenOddSource(Complex* y, const Complex* x) const
{
  // Create the source required to do an even-odd inversion. Note that it's
  // assumed here that x is ***already*** even-odd ordered, and in fact that
  // x is actually the even part of the source vector (the lower half). y is
  // then the lower half of the source, which is all you need for the solve

  Complex* z;
  cudaMalloc((void**) &z, this->N / 2 * sizeof(Complex));

  this->applyEvenEvenInv(y, x);
  this->applyOddEven(z, y);

  int dimGrid;
  int dimBlock;
  setGridAndBlockSize(dimGrid, dimBlock, this->N / 2);
  assignDev<<<dimGrid,dimBlock>>>(y, x, this->N / 2);

  saxpyDev<<<dimGrid,dimBlock>>>(y, z, -1.0, this->N / 2);

  cudaFree(z);
}



void CudaLinearOperator::makeEvenOddSolution(Complex* y, const Complex* x) const
{
  // Do the inverse of what makeEvenOddSource does. Note that the final y
  // that's computed is still in even-odd form, and the vector must be
  // transferred to the host before calling removeEvenOdd on it.

  Complex* z;
  cudaMalloc((void**) &z, this->N / 2 * sizeof(Complex));

  this->applyEvenOdd(y, x);
  this->applyEvenEvenInv(z, y);

  int dimGrid;
  int dimBlock;
  setGridAndBlockSize(dimGrid, dimBlock, this->N / 2);
  assignDev<<<dimGrid,dimBlock>>>(y, x, this->N / 2);

  saxpyDev<<<dimGrid,dimBlock>>>(y, z, -1.0, this->N / 2);

  cudaFree(z);
}
