
CudaLinearOperator::CudaLinearOperator(const int L, const int T, const int precondition,
			       const int hermitian, Complex* links,
			       const bool copyLinks)
  : super(12 * L * L * L * T, 12 * L * L * L * T)
{
  this->N = 12 * L * L * L * T;
  this->L_ = L;
  this->T_ = T;

  this->precondition_ = precondition;
  this->hermitian_ = hermitian;

  // Number of complex numbers in the array of links
  if (copyLinks) {
    int size = 3 * this->N * sizeof(Complex);
    cudaMalloc((void**) &this->links_, size);
    cudaMemcpy(this->links_, links, size, cudaMemcpyHostToDevice);
  }
  else
    this->links_ = links;
}



CudaLinearOperator::~CudaLinearOperator()
{
  cudaFree(this->links_);
}



void CudaLinearOperator::operator()(const VectorTypeDev& x,
				    VectorTypeDev& y) const
{
  const Complex* x_ptr = thrust::raw_pointer_cast(&x[0]);
  Complex* y_ptr = thrust::raw_pointer_cast(&y[0]);

  if (this->precondition_) {
    if (this->hermitian_)
      this->applyPreconditionedHermitian(y_ptr, x_ptr);
    else
      this->applyPreconditioned(y_ptr, x_ptr);    
  }
  else {
    if (this->hermitian_)
      this->applyHermitian(y_ptr, x_ptr);
    else
      this->apply(y_ptr, x_ptr);
  }
}



void CudaLinearOperator::makeEvenOdd(Complex* y, const Complex* x) const
{
  // Permutes the supplied spinor, shuffling it so the upper half contains
  // the even sites and the lower half contains the odd sites
}



void CudaLinearOperator::removeEvenOdd(Complex* y, const Complex* x) const
{
  
}
