"""
Here we compute two-point functions for all 256 combinations of meson
interpolators using different smearing combinations at the source and sink.

To do this we write a custom measurement function to reuse the propagators when
performing smearing at the sink.

We load the ensemble generated by the generate_configs.py script here to save
computation time.
"""

import logging

import numpy as np

import pyQCD

pyQCD.Log(ignore=("lattice",))
def compute_correlators(lattice, mass_1, mass_2):
    """Computes all 256 meson correlation functions for the two supplied
    quark masses and all four possible source/sink smearing combinations"""

    out = {}
    log = pyQCD.logger()

    # Could do some smearing here
    #backup_config = lattice.get_config()
    #lattice.stout_smear(2, 0.4)

    # Create the inversion functions and smearing functions we'll use when doing
    # the inversion.
    invert_mass_1 \
      = lambda psi: lattice.invert_wilson_dirac(psi, mass_1, precondition=True,
                                                solver_info=True)
    invert_mass_2 \
      = lambda psi: lattice.invert_wilson_dirac(psi, mass_2, precondition=True,
                                                solver_info=True)

    smear_func = lambda psi: lattice.apply_jacobi_smearing(psi, 2, 0.4)

    pt_src = lattice.point_source([0, 0, 0, 0])
    
    # Next we need the propagators. We do unsmeared first (the default).
    prop_LL_mass_1 = pyQCD.compute_propagator(pt_src, invert_mass_1)
    prop_LL_mass_2 = pyQCD.compute_propagator(pt_src, invert_mass_2)

    # Smear these propagators with two jacobi smears and a parameter of 0.4
    prop_LS_mass_1 = pyQCD.smear_propagator(prop_LL_mass_1, smear_func)
    prop_LS_mass_2 = pyQCD.smear_propagator(prop_LL_mass_2, smear_func)
    
    # Now we need compute the propagators with source smearing.
    # We do unsmeared first (the default).
    
    log.info("Computing smeared-point prop for mass = {}".format(mass_1))
    prop_SL_mass_1 = pyQCD.compute_propagator(pt_src, invert_mass_1, smear_func)
    log.info("Computing smeared-point prop for mass = {}".format(mass_2))
    prop_SL_mass_2 = pyQCD.compute_propagator(pt_src, invert_mass_2, smear_func)
    
    # Smear these propagators with two jacobi smears and a parameter of 0.4
    log.info("Smearing smeared-point prop with mass = {}".format(mass_1))
    prop_SS_mass_1 = pyQCD.smear_propagator(prop_SL_mass_1, smear_func)
    log.info("Smearing smeared-point prop with mass = {}".format(mass_2))
    prop_SS_mass_2 = pyQCD.smear_propagator(prop_SL_mass_2, smear_func)
    
    mass_1_props = [prop_LL_mass_1,
                    prop_LS_mass_1,
                    prop_SL_mass_1,
                    prop_SS_mass_1]
    
    mass_2_props = [prop_LL_mass_2,
                    prop_LS_mass_2,
                    prop_SL_mass_2,
                    prop_SS_mass_2]
    
    prop_pairings = [(p1, p2) for p1 in mass_1_props for p2 in mass_2_props]

    smearing_combinations \
      = ["{}{}".format(x, y)
         for x in ["LL", "LS", "SL", "SS"]
         for y in ["LL", "LS", "SL", "SS"]]
        
    # Now we go through and contract all propagator combinations    
    for (prop1, prop2), smear_comb in zip(prop_pairings, smearing_combinations):

        log.info("Computing meson correlators for smearing combination "
                 "{}".format(smear_comb))
        correlators = pyQCD.compute_meson_corr256(prop1, prop2)
        # Merge the smearing labels into existing dict keys
        correlators = dict([((key,) + (smear_comb,), value)
                            for key, value in correlators.iteritems()])
        out.update(correlators)

    # If we'd smeared, we'd restore the config here
    #lattice.set_config(backup_config)
        
    return out

if __name__ == "__main__":

    logging.basicConfig(level=logging.INFO)
    
    # As in generate_configs.py, we create a lattice then use it to create a
    # simulation. Since we're providing an ensemble the number of thermalization
    # steps doesn't do anything here.
    lattice = pyQCD.Lattice(4, 8, 5.5, "rectangle_improved", 10)
    simulation = pyQCD.Simulation(lattice, 100, 100)

    # Here we specify the callback function that'll load the existing gauge
    # field configurations, as well as the indices to iterate over when loading
    # the configurations. Here the callback function accepts a single integer
    # index denoting the number of the config to load.
    fname = "4c8_ensemble.zip"
    simulation.specify_ensemble(pyQCD.io.extract_datum_callback(fname),
                                list(range(simulation.num_configs)))
    
    # Now add our new measurement. compute_correlators returns a dictionary,
    # which we process and store using another write_datum callback. We also
    # need to provide parameters, so they're specified as keyword args.
    fname = "4c8_correlators_m0.4_m0.03.zip"
    simulation.add_measurement(compute_correlators,
                               pyQCD.io.write_datum_callback(fname),
                               kwargs={'mass_1': 0.4, 'mass_2': 0.03})

    # And run the simulation
    simulation.run()
